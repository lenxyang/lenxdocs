\section{内核加载}

\section{进入保护模式}
在进入开始介绍内存管理之前，我们需要让我们的系统进入保护模式并开启分页机制，虽然这部分内容如果使用C语言来写应该非常的简单，但这部分内容确实使用汇编语言实现，这绝对不是为了让读者看起来很cool。采用这种技术是有原因，理解这个原因是非常重要的。

在保护模式下，程序有了4G的寻址空间（其实这个问题比较复杂，很难一两句说清楚，在内存管理部分我们再详细的讲）。Linux内核将4G空间划分成了两个部分，用户控件（0G～3G）及内核空间（3G～4G）。vmlinux在加载的时候其实并不位于3G～4G空间之上。
原因包括多个：首先PC机并未启动分页机制，它能访问的是物理内存，而无力内存有没有4G很难说。第二及时真的有4G内存，在进入保护模式之前，16位的程序也没有办法访问到这些物理内存。

因此Linux采用了一个很精巧的办法，将vmlinux加载到低端内存。再启动分页机制后将它映射到高端内存上。这对C程序来说绝对是个挑战，因为从链接的时刻各个符号的地址已经确定了，如果要写两个模式下运行的程序，每看到一个符号叫要想想现在处于什么模式，究竟是以物理内存还是用虚拟内存的方式访问这个符号。如果是以物理内存的方式访问，还要进行指针运行而后在进行类型转换，想想都头大。

简单的做法是写一段汇编代码，这段代码之后就进入分页模式，C程序向怎么写就怎么写；再次之前就要讲过一些运算了，不过这段代码比较短，整体还是可以接受的。由于进入内核之前必须先执行这段代码，因此这段代码的名字就叫做head.S（完整路径是arch/i386/kernel/head.S）。我们的代码做了很大简化，感兴趣的同学可以对比，具体代码如下:
\begin{lstlisting}
	
\end{lstlisting}
这部代码就是Linux进入保护模式的代码，从当中可以看到Linux包含两部分的

当中还是包含很多将来要用的东西的，比如cpu\_gdt\_table。 在系统初始化阶段Linux采用boot\_gdt\_table。在正式启动之后将会切换到cpu\_gdt\_table上来。

好了到现在为止我们的系统已经进入了保护模式，接下来我们逐个初始化操作系统的子系统。


\section{构建新的内核}

内核是有汇编和C联合编写的，与寻常的程序不同，我们不能简单的ld \$(LDFLAGS) fileslist -o vmlinux，而使使用一种叫做ldscript的脚本。 ld script提供了非常有用的功能，使我们在编写内核的时候更简单:
1. 制定不同段的位置
2. 将多个段合并成一个段
3. 初始化全局变量

在启动分页机制的时候大家注意到了变量pg，它保存了全局页表，当将它放在那里呢？最好的位置是程序的尾部，但在链接之前我们是不知道程序的尾部在那里，不过没关系，ld script可以告诉我们。
\begin{lstlisting}[language=bash]


\end{lstlisting}


\subsection{ldscript}
ldscript非常的容易

\subsection{模仿Linux的机制}
Linux调用lds并不像我们介绍的那么简单直接，因为它真的做了一些使的代码更容易维护的事情。但为了提高维护性，我们必须提高我们对工具的使用能力才行。
首先来介绍一下linux使用lds的方式，它并不直接使用lds文件，而是使用一种叫做lds.S的文件之后来生成lds文件，为什么这么作呢，因为linux希望所有的变量都统一的放在一个地方，而不是分散在各地。但是lds是不支持包含C语言的头文件的。但是.S文件支持，即GAS格式的汇编语言文件。

GAS格式的汇编文件有两种.s和.S，这两种文件有一个微小的不同，虽然微小但足够让你崩溃一天。.s和.S的文件都支持gcc或者as进行汇编，但是.s的文件是直接忽略include指令的，是的直接忽略还不报错，让你误以为引入了都文件但实际上没有。如果你在你的汇编程序中用到了某个\#define定义的常量，它也不报语法错误，而是报undefined symbol。这个错误如此具有误导性，以至于我会怀疑C语言通过\#define定义的常量会包含在symbol table当中。但实际上完全不会，它仅仅是没有包含头文件而已，把扩展名换成.S立时所有的问题都没有了。

